## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity 中存储成本最高的变量类型是`_状态__`变量，其数据永久存储在区块链上。
2. 使用`_constant__`关键字声明的常量可以节省 Gas 费，其值必须在编译时确定。
3. 当合约收到不带任何数据的以太转账时，会自动触发`_receive__`函数。

---

### 二、选择题

4. 函数选择器(selector)的计算方法是： B

   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前 4 字节  
   **C)** 函数参数的 ABI 编码  
   **D)** 函数返回值的类型哈希

5. 以下关于 mapping 的叙述错误的是： C

   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套 mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和 Gas 退还角度）

1.require 用于验证输入参数/验证返回值/验证状态条件等，错误会退还 gas 给调用者
2.assert 用于检查内部错误/验证不变量/确保代码不可能出现的情况，错误了不会退化 gas
3.revert 用于需要复杂条件判断的情况，主动回滚交易，错误会退还 gas 给调用者

7. 某合约同时继承 A 和 B 合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

实际执行会调用最右边（最后）继承的合约 B 中的 foo() 函数。这是因为 Solidity 使用 C3 线性化算法 来解决多重继承的问题，继承顺序从左到右，最右边的合约优先级最高

8. 当使用`call`方法发送 ETH 时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

1.gas 限制：transfer 固定 2300 gas 限制，call 可以自定义，没有限制 2.错误处理：transfer 错误会自动回滚，call 返回成功或失败，需要手动检查 3.安全：transfer 更安全，因为 gas 限制防止重入攻击，call 需要手动实现重入保护 4.接收合约兼容性：transfer 接收合约的 fallback/receive 函数必须在 2300 gas 内完成，call 更灵活，适用于复杂的接收合约
