## 第五章：Monad 101
 
1. 请简述 Monad 中的“延迟执行”概念。该机制如何优化共识与执行之间的关系？

在传统的以太网链中，每个区块必须是先执行后共识, 然后开始下一个区块。
在 Monad 中，第一个区块共识完成之后，就直接开始第二个区块的共识，同时进行第一个区块的执行，这样就达到了并行执行的效果。
这样就对执行操作进行了延迟执行的处理。
通过这样的机制，将执行和共识进行了分离，最终会节省出因串行浪费的系统总时间，使得单位时间有更大的交易吞吐量。


2. 什么是乐观并行执行？其工作流程包含哪些关键步骤？

乐观并行执行是指在交易执行时，先假设所有交易都没有依赖关系，都是独立的，然后非给计算单元并行执行。
关键步骤：
   1. 假设交易是独立的，并有相同的初始状态
   2. 记账，现将交易读取了哪些状态，修改了哪些状态记下来
   3. 提交待处理结果，在保证原始区块顺序的前提下，提交上一步记账的结果
   4. 冲突检测，重新执行，如果第三步中发现有冲突的交易，需要重新执行，这次不是乐观执行了，需要一个一个串行执行知道没有冲突为止。


3. 在 Monad 架构中，如何通过并行执行仍保持交易的线性排序与状态一致性？

在乐观并行执行中，当提交预处理结果时，就已经保证了交易的线性顺序。
如果在提交待处理结果中发现有冲突交易，就会重新执行直到没有冲突为止，保证了状态一致性。


4. Monad 的共识机制monadBFT有哪些特点？它与传统 BFT 共识相比有何优势？

首先 monad 的共识机制是线性的，是 2-chain commit rule，就是可以通过三个 block 就能完成对第一个 block 的共识。
不需要等到这个 block 被完全共识完成后，才开始下一个 block 的共识。而是并行执行，比如 block n 开始进行领导者收集投票为 qc（n) 时，
block n+1 也开始进行第一个领导者qc（n-1) 了。他们是并行处理的。

相比于传统的 bft 共识，比如以太网链，必须是先执行后共识，最后才能开始下一个 block 的共识。
Monad 则是多个区块进行并行共识，明显提高了共识速度和共识的吞吐量。

5. 为什么 Monad 采用“Optimistic Concurrency Control”？它在处理交易冲突方面是如何工作的？

传统的悲观并发控制是先假设了冲突很可能发生，先使用事务锁定数据，然后直到事务结束后才释放锁。
虽然保证了数据的一致性，但是在高并发场景下，就会严重降低系统的整体处理能力，造成性能瓶颈。

Monad 的乐观执行是先假设没有冲突发生，先执行，然后在提交待处理结果时，才会检查是否有冲突。
这样明显的改变是，只要实际的冲突率不高，就会大幅度提升系统的吞吐量和响应速度。

Monad 的交易冲突的解决方式是，先记住交易的读写状态，然后在提交待处理结果时，检查是否有冲突。
如果有冲突，就会重新执行，直到没有冲突为止。

就是如果冲突很少，效率就很过，如果每个交易都有冲突，就可能回退到传统串行执行的方式了。

