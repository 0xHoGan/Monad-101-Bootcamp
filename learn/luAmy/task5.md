## 第五章：Monad 101
 
1. 请简述 Monad 中的“延迟执行”概念。该机制如何优化共识与执行之间的关系？
通过先共识再执行，共识完成后立即开始下一个节点的共识阶段，就节约下来了每个节点执行花费的时间。

2. 什么是乐观并行执行？其工作流程包含哪些关键步骤？
假设每笔交易开始前状态都是一致的，那么在开始执行时，每笔交易都先执行，如果执行过程中有冲突，则冲突的节点会重新执行，直到所有交易执行完成。
步骤：从相同的初始状态执行，生成所有待处理结果，记录输入输出，按顺序提交待处理结果，如果有冲突重新执行。

3. 在 Monad 架构中，如何通过并行执行仍保持交易的线性排序与状态一致性？
​​确定性排序​​：在交易进入执行阶段前，通过共识机制（如 BFT 类算法）预先确定交易的全局顺序。所有节点在共识层对交易顺序达成一致，生成唯一的序列化交易队列。
​​顺序标识​​：为每个交易分配递增的时间戳或序列号，确保即便并行执行，最终提交顺序严格遵循预定义的序列。
乐观并发控制（OCC）​​：
​​无锁执行​​：交易在独立的执行环境（如沙盒或虚拟状态副本）中并行运行，无需锁定共享资源。
​​状态版本化​​：每个交易基于最新的已知状态版本（快照）执行，记录其读写集（Read-Write Set）。
冲突检测与状态验证​​
​读写集分析​​：
每个交易执行后，提取其访问的存储键（Keys）及修改操作。
​​批处理提交​​：将无冲突的交易批次按全局顺序原子化提交到状态数据库，保证结果的一致性。
​​状态回滚机制​​：对检测到冲突的交易批次，触发回滚并重新排序执行，可能结合局部重试或依赖调整策略。

4. Monad 的共识机制monadBFT有哪些特点？它与传统 BFT 共识相比有何优势？
MonadBFT 的核心特点​​
1. ​​线性通信复杂度（O(n)）​​
​​机制​​：采用分层聚合签名（如 BLS 阈值签名）和流水线化消息传递，节点间通信复杂度从传统 PBFT 的 O(n²) 降至 O(n)。
​​效果​​：支持数千节点参与共识，网络扩展性大幅提升。
2. ​​确定性最终性（Instant Finality）​​
​​机制​​：单轮共识即可完成交易确认，无需等待多区块确认。
​​效果​​：交易在出块后立即不可逆，消除分叉风险，适合高频金融场景。
3. ​​异步网络适应性​​
​​机制​​：基于部分同步网络假设优化，允许节点在消息延迟波动时仍能推进共识。
​​效果​​：在现实网络环境下保持高可用性，避免传统 BFT 因临时网络中断导致的停滞。
4. ​​并行化共识流水线​​
​​机制​​：将共识流程分解为 ​​排序（Ordering）​​ → ​​执行（Execution）​​ → ​​验证（Validation）​​ 的并行流水线。
​​效果​​：隐藏各阶段延迟，实现高吞吐量（10万+ TPS）与低延迟（亚秒级确认）。
5. ​​状态快照同步​​
​​机制​​：通过无状态验证节点（Stateless Validators）和增量状态证明（Incremental State Proofs），降低新节点加入的同步成本。
​​效果​​：支持动态节点加入/退出，提升去中心化程度。

MonadBFT 对比传统 BFT 的核心优势​​：
​​通信效率​​
MonadBFT 通过聚合签名和分层广播实现 ​​线性通信复杂度（O(n)​​，传统 BFT（如 PBFT）为 O(n²)，节点扩展性提升 10 倍以上。
​​即时最终性​​
单轮共识即可确认交易（​​1 秒内不可逆​​），传统 BFT 需 3+ 轮交互（6-10 秒确认）。
​​抗分叉机制​​
独创尾部分叉抵抗技术，消除传统流水线 BFT 中 5% 的合法区块废弃问题。
​​异步网络容忍​​
允许 20% 网络丢包率下维持运行，传统 BFT 依赖严格同步网络，易因延迟中断。
​​动态节点扩展​​
支持 200+ 全球化验证节点（传统 BFT 通常限制在 100 节点内），通过硬件指纹认证提升去中心化。
​​性能优化​​
流水线化设计实现 10,000+ TPS（传统 BFT 仅 1,000 TPS），普通服务器即可运行。

5. 为什么 Monad 采用“Optimistic Concurrency Control”？它在处理交易冲突方面是如何工作的？
因为这样执行效率更高，可以并行执行所有不冲突的交易。
在事务提交之前，验证是否有其他交易已经修改了它读取的数据。如果有冲突就回滚，重新执行。没有冲突就提交事务。


