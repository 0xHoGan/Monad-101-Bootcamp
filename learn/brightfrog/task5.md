## 第五章：Monad 101

### 请简述 Monad 中的“延迟执行”概念。该机制如何优化共识与执行之间的关系？

它将执行和共识分离，采用流水线式的共识与执行分级机制。这意味着在 Monad 中，节点只需就交易排序达成一致，而实际执行交易并更新状态则独立进行。

例如，我们先完成共识，确定交易顺序，然后将执行过程放在另一条流水线并行执行。在区块二中，进行共识的同时，也在执行区块一的交易，此阶段进行交易执行及状态更新，循环往复。
因此，实际时间仅限于共识时间，执行时间得以延长，从而单个区块可容纳更多交易。

使用延迟执行时，无需为执行付出额外时间成本。在一般区块链如以太坊中，执行交易是达成共识的前提，导致每个节点必须先执行所有交易，再与其他节点共识，极大限制了处理能力。而在 Monad 中，取消此限制，达成共识前不必执行交易，只需专注排序。这种设计使 Monad 大幅提升交易速度，支持数百万用户规模。执行首个交易同时，第二个区块的共识已可开始。
优化后主要有两大优势：一是更多执行时间，每个区块有更多时间用于交易执行，意味着单个区块可存储更多交易；二是更高吞吐量，因执行与共识分离，每个区块执行交易更高效，提升整体吞吐量。
总结而言，Monad 的延迟执行为区块性能带来巨大提升。

在执行前达成交易顺序的共识，使得极点能高效处理交易，无需等待每个区块的完整执行。当一个区块执行时，下一个区块已在共识阶段，大幅提升系统吞吐量。每个极点独立计算执行结果，中心在共识达成时仅进行确认，确保系统安全性与一致性。

### 什么是乐观并行执行？其工作流程包含哪些关键步骤？

在当前区块链系统中，交易呈线性排列，即所有交易必须按照既定顺序依次进行。
这确保每一笔交易的结果都基于之前的交易状态，产生新的结果。然而，Monad 的目标是保留交易线性排序的特性，同时通过并行处理提升效率。这意味着在幕后执行过程中，Monad 仍能确保交易顺序和最终状态的完整性

让我们详细了解 Monad 的乐观并行执行过程。该过程可分为四个步骤：

首先，乐观执行阶段。系统允许所有交易从相同的初始状态开始变形处理。
其次，生成待处理结果阶段。每笔交易记录其修改和读取的状态及存储的数据，这些待处理结果将被记录，以便后续检测和调整。
第三，提交待处理结果阶段。所有处理结果按交易的原始顺序提交，确保最终执行保持线性排序属性。
最后，重新执行阶段。若在提交时发现交易间存在冲突，将根据情况重新执行这些交易。

### 在 Monad 架构中，如何通过并行执行仍保持交易的线性排序与状态一致性？

- 从相同的起始点执行多笔交易
- 生成多个待处理结果，并记录输入输出
- 按顺序提交待处理结果
- 如有必要，重新执行

例如，假设有四笔交易，其中两笔无冲突，可完全并行执行。
另外两笔交易存在冲突。在执行过程中，我们首先将前一个区块的状态作为输入，并行执行这两笔交易
执行完毕后，将获得相应的输出。观察第一笔交易，结果显示我拥有 900 个 USDC，Alice 拥有 100 个 USDC。第三笔交易结果显示我仍拥有 900 个 USDC，Bob 则变为 400 个 USDC。显然，这里存在一些问题。
正常流程应先进行第一笔交易的验证，即我们之前提到的第三个阶段——提交阶段。随后进行第二笔交易的提交，再进行第三笔交易的提交。然而，当前系统发生冲突，因为当前状态与第一笔交易的状态存在冲突。
在这种情况下，需重新执行交易，将输入恢复至先前提交的状态，以确保状态一致性。通过上述例子可知，即使在并行执行的情况下，也存在类似乐观锁的机制来保障数据安全。
此外，重新执行的成本较低，因为数据已被读取并缓存，节省了重复计算时的读取开销。操作便捷，无需访问列表，进一步简化了处理过程。所有这些优化均由 Monet 底层实现。最后是数据部署。

### Monad 的共识机制 monadBFT 有哪些特点？它与传统 BFT 共识相比有何优势？

- 分离共识与执行
  - MonadBFT 将共识和执行过程分离，采用流水线式的共识与执行分级机制
  - 节点只需就交易排序达成一致，而实际执行交易并更新状态则独立进行
  - 这种设计使得共识过程更加高效，因为不需要等待交易执行完成
- 延迟执行机制
  - 在区块二中，进行共识的同时，也在执行区块一的交易
  - 实际时间仅限于共识时间，执行时间得以延长，从而单个区块可容纳更多交易
  - 无需为执行付出额外时间成本，大幅提升交易处理速度

与传统 BFT 相比的优势：

- 更高的吞吐量：通过分离共识和执行，每个区块可以更高效地处理交易
- 更好的可扩展性：支持数百万用户规模，能够处理更多交易
- 更低的延迟：执行首个交易的同时，第二个区块的共识已经开始
- 更高的效率：节点不需要等待交易执行完成就可以开始下一轮共识
- 安全性保证
  - 在执行前达成交易顺序的共识，确保交易的有序性
  - 每个节点独立计算执行结果，中心在共识达成时仅进行确认
  - 通过乐观并行执行机制，在保持交易线性排序的同时提升效率
- 性能优化
  - 通过流水线处理，大幅提升系统吞吐量
  - 单个区块可以存储更多交易
  - 执行时间得到延长，提高整体处理效率

### 为什么 Monad 采用“Optimistic Concurrency Control”？它在处理交易冲突方面是如何工作的？

- OCC 假设多个事务可以并发执行地完成而不会相互冲突
- 区块中的交易在运行时，会访问数据资源，但不需要提前锁定这些资源
- 在事务提交之前，系统会验证是否有其他事务已经修改了他所读取的数据
- 如果检测到冲突，系统会进去回滚状态，取消事务的执行
- 如果没有冲突，则可以安全的提交交易结果
