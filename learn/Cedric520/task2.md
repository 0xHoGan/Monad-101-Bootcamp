### 一、填空题
1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。

2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。

3. 当合约收到不带任何数据的以太转账时，会自动触发`receive()`函数。

---

### 二、选择题
4. 函数选择器(selector)的计算方法是：A

***A)*** sha3(函数签名)

***B)*** 函数名哈希的前4字节

***C)*** 函数参数的ABI编码

***D)*** 函数返回值的类型哈希

5. 以下关于mapping的叙述错误的是：C

***A)*** 键类型可以是任意基本类型

***B)*** 值类型支持嵌套mapping

***C)*** 可以通过length属性获取大小

***D)*** 无法直接遍历所有键值对

---

### 三、简答题
6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

1.`require`

触发条件：

用于验证输入条件或外部调用的返回值。

通常用于检查用户输入、权限验证、函数调用的前提条件等。

如果条件不满足，抛出异常并中止执行。

Gas 退还：

退还剩余 Gas。

未使用的 Gas 会退还给调用者，因为 require 表示的是预期内的错误（如输入无效）。

2.`assert`

触发条件：

用于检查逻辑错误或程序状态，通常用于检测代码中不可能出现的错误。

例如，验证变量的状态是否符合程序设计的预期。

如果 assert 失败，表示程序存在严重的错误或漏洞。

Gas 退还：

不退还剩余 Gas。

所有剩余 Gas 会被消耗，因为 assert 失败表示严重的程序错误，开发者需要修复代码。

3.`revert`

触发条件：

用于手动抛出异常，通常是为了中止程序执行并返回自定义错误消息。

适用于更复杂的条件判断，或者需要在某种情况下直接中止程序。

Gas 退还：

退还剩余 Gas。

类似`require`，`revert`失败表示预期内的错误。

7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
 contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

在Solidity中,当合约 C 继承了多个父合约（如 A 和 B），并且这些父合约都定义了同名函数（如 foo()），合约 C 重写了该函数时，那么调用的就是c中的foo函数，而不会调用A，B中的foo函数。

在Solidity中,当合约 C 继承了多个父合约（如 A 和 B），并且这些父合约都定义了同名函数（如 foo()），但合约 C 没有重写该函数时，函数调用的顺序和最终调用哪个父合约的函数取决于 Solidity 的线性化继承顺序。

线性化顺序：C -> B -> A
合约 C 的继承列表是 A, B，但线性化顺序会将 B 放在 A 之前，因为 B 是更“右侧”的父合约。
因此，当调用 foo() 时，会先查找 B 的定义，再查找 A 的定义。

线性化顺序通常遵循以下规则：
子合约优先。
父合约按照继承列表从右到左的顺序展开。
每个父合约的继承链依次展开。
因此，在大多数情况下，右侧的父合约（或其继承链中的合约）的函数会优先被调用。

8. 当使用call方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```

这两种方法在发送 ETH 时有以下本质区别：
- Gas 限制
call 方法 ：
addr.call{value: 1 ether}("") 会将除了预留用于执行当前上下文代码的费用之外的几乎所有可用 gas 都转发给被调用的合约，这意味着它允许被调用合约执行较为复杂的操作，因为有足够的 gas 来支持这些操作执行。
- 例如，如果被调用合约有一个复杂的接收逻辑，比如需要进行多个内部状态更新、调用其他函数等操作，call 这种方式由于提供了较多的 gas 就能够比较顺利地完成这些任务。
transfer 方法 ：
addr.transfer(1 ether) 只会转发 2300  gas被调用合约。这个数量的 gas 是有限的，基本上只能用于执行简单的接收逻辑，比如直接把 ETH 存入合约的余额中，而不能进行复杂的操作调或者用其他消耗较多 gas 的函数。
这是出于安全考虑设计的，因为如果一个合约调用另一个合约接收 ETH，而接收合约有一个恶意的耗尽 gas 的操作，使用 transfer 方法可以防止过多的 gas 被消耗，从而避免潜在的拒绝服务攻击等情况。
- 异常处理
call 方法 ：
call 方法不会自动抛出异常。如果被调用合约的接收函数执行失败，比如被调用合约没有收到 ETH 时应该执行的操作没有正确完成，它只会返回一个布尔值表示调用是否成功。例如，如果被调用合约的接收函数抛出了异常，call 不会将这个异常抛出到调用它的合约中，而是返回 false，调用者需要自己检查返回值来判断是否调用成功。
transfer 方法 ：
transfer 方法会自动检查 ETH 的发送是否成功。如果被调用合约接收 ETH 失败，比如因为被调用合约的接收逻辑有错误或者拒绝接收等情况，transfer 会抛出一个异常，这会导致整个交易回滚，除非在这段代码中有适当的异常捕获机制来处理这种情况。
- 调用深度
call 方法 ：
call 可以调用任何地址，无论是合约地址还是外部账户地址，它对于调用没有深度像 transfer 那样有限制。
transfer 方法 ：
transfer 是专门用于发送 ETH 的便捷方法，它隐式地使用了 call，但它的调用深度是有限制的，它主要适用于简单地将 ETH 发送到另一个地址的情况，而不适合复杂嵌套调用场景。
- 返回值
call 方法 ：
它返回两个值，第一个值是布尔类型，表示调用是否成功；第二个值是 bytes 类型，包含被调用函数返回的数据（如果有的话）。
transfer 方法 ：
它没有返回值，只是简单地执行 ETH 的发送操作。