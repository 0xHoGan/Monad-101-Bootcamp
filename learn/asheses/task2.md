## 第二章：Solidity 快速入门

### 一、填空题

1. Solidity中存储成本最高的变量类型是`storage`变量，其数据永久存储在区块链上。  
2. 使用`constant`关键字声明的常量可以节省Gas费，其值必须在编译时确定。  
4. 当合约收到不带任何数据的以太转账时，会自动触发`receive`函数。  

---

### 二、选择题

4. 函数选择器(selector)的计算方法是：  B
   **A)** sha3(函数签名)  
   **B)** 函数名哈希的前4字节  
   **C)** 函数参数的ABI编码  
   **D)** 函数返回值的类型哈希  

5. 以下关于mapping的叙述错误的是：  C
   **A)** 键类型可以是任意基本类型  
   **B)** 值类型支持嵌套mapping  
   **C)** 可以通过`length`属性获取大小  
   **D)** 无法直接遍历所有键值对  

---

### 三、简答题

6. 请说明`require`、`assert`、`revert`三者的使用场景差异（从触发条件和Gas退还角度）

1) require​用于验证​​外部输入​​和​​前置条件​​，例如用户权限、参数合法性或合约状态合法性（如余额是否充足）,触发时退还​​所有剩余 Gas​​ 给调用者，仅消耗已使用的 Gas
2) assert检查​​内部逻辑错误​​和​​不变量（Invariants）​​，例如算法溢出、数组越界或合约状态矛盾（如总量不应为负）,会消耗​​全部 Gas​​
3) revert适用于​​复杂逻辑流​​中的错误处理，允许自定义错误消息或条件分支，可单独使用或结合条件语句，触发时退还剩余 Gas

7. 某合约同时继承A和B合约，两者都有`foo()`函数：

```solidity
contract C is A, B {
    function foo() override(A,B) {...}
}
```

实际执行时会调用哪个父合约的函数？为什么？

  B,因为继承顺序从右到左​​：子合约继承列表中，​​右侧的合约优先级更高​​。

8. 当使用`call`方法发送ETH时，以下两种写法有何本质区别？

```solidity
(1) addr.call{value: 1 ether}("")
(2) addr.transfer(1 ether)
```
1) addr.call{value: 1 ether}("")：​​无 Gas 限制​​ ，允许接收合约执行 ​​复杂逻辑​​（如调用其他函数、修改状态变量），适合需要与接收合约交互的场景。需开发者显式处理失败（如 require(success)），否则交易继续执行，可能导致状态不一致。此外，无 Gas 限制可能引发 ​​重入攻击​​ 。

2) addr.transfer(1 ether)：固定 ​​2300 Gas​​，仅支持简单转账，接收合约的 receive() 或 fallback() 函数 ​​不能包含复杂逻辑​​（如存储操作、循环等），否则会因 Gas 不足失败。安全性较高，但 Gas 限制可能导致意外失败（如接收合约升级后逻辑变复杂）。

